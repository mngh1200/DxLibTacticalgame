#include "Map.h"
#include "Entity/Unit/Unit.h"

namespace Entity {
	/**
	 * @fn
	 * コンストラクタ
	 */
	Map::Map()
	{
		type_ = Object::Type::MAP;

		weak_ptr<Unit> tmpUnit;

		if (tmpUnit.expired()) {
			int a = 10;
		}

		shape_.set(0, MAP_Y, MAP_MASS_W * CHIP_SIZE, MAP_MASS_H * CHIP_SIZE);

		mass_.reserve(MAP_MASS_H); // メモリ確保

		// マップデータ生成
		for (int y = 0; y < MAP_MASS_H; y++)
		{
			mass_.push_back(vector<shared_ptr<Mass>>());
			mass_[y].reserve(MAP_MASS_W); // メモリ確保
			
			for (int x = 0; x < MAP_MASS_W; x++)
			{
				int kind = Mass::Kind::PLAIN;

				if (x == 0 || x == MAP_MASS_W - 1)
				{
					kind = Mass::Kind::MOUNTAIN;
				}
				else if (y == 5)
				{
					kind = Mass::Kind::RIVER;
				}
				else if (x == 5)
				{
					kind = Mass::Kind::FOREST;
				}

				mass_[y].push_back(make_shared<Mass>(kind));
			}
		}
	}

	/**
	 * @fn
	 * 描画
	 */
	void Map::render() const
	{
		Utility::ResourceManager& rm = Utility::ResourceManager::getInstance();

		int x = 0;
		int y = 0;

		int mouseX = -1;
		int mouseY = -1;

		if (isMouseOver_) // ホバー時のみ取得
		{
			DxLib::GetMousePoint(&mouseX, &mouseY);
			mouseX = getMassX(mouseX);
			mouseY = getMassY(mouseY);
		}

		for (auto line = mass_.begin(); line != mass_.end(); ++line) {
			for (auto cell = (*line).begin(); cell != (*line).end(); ++cell) {
				int realX = getRealX(x);
				int realY = getRealY(y);
				DxLib::DrawGraph(realX, realY, (*cell)->getImageId(), FALSE);

				
				if (isMouseOver_) // ホバー時の描画
				{
					if (x == mouseX && y == mouseY)
					{
						drawHoverMass(realX, realY);
					}
				}

				if ((*cell)->state == Mass::State::NORMAL)
				{
					// 何もしない
				}
				if ((*cell)->state == Mass::State::MOVABLE) // 移動範囲
				{
					drawMoveableMass(realX, realY);
				}
				else if ((*cell)->state == Mass::State::ATK_ABLE) // 攻撃可能範囲
				{
					drawAtackMass(realX, realY);
				}
				++x;
			}
			++y;
			x = 0;
		}
	}

	/**
	 * @fn
	 * 特定マスにユニット設置
	 * @param (unit) ユニット
	 */
	bool Map::setUnit(shared_ptr<Entity::Unit> unit)
	{
		int x = unit->getMassX();
		int y = unit->getMassY();

		if (isRange(x, y))
		{
			auto ret = units_.emplace(make_pair(x, y), unit); // 新規追加のみ
			return ret.second;
		}
		return false;
	}

	/**
	 * @fn
	 * 特定マスのユニット取得
	 * @param (massX) マス座標X
	 * @param (massY) マス座標Y
	 */
	shared_ptr<Unit> Map::getUnit(int massX, int massY)
	{
		pair<int, int> pos = make_pair(massX, massY);
		if (units_.count(pos) > 0)
		{
			return units_.at(pos);
		}

		return nullptr;
	}

	/**
	 * @fn
	 * 対象ユニットを座標上から削除
	 * @param (unit) 対象ユニット
	 */
	void Map::eraseUnit(shared_ptr<Unit> unit)
	{
		units_.erase(make_pair(unit->getMassX(), unit->getMassY()));
	}

	/**
	 * @fn
	 * ユニットリストのイテレータの始点を返す
	*/
	map<pair<int, int>, shared_ptr<Unit>>::iterator Map::unitsBegin()
	{
		return units_.begin();
	}

	/**
	 * @fn
	 * ユニットリストのイテレータの終点を返す
	*/
	map<pair<int, int>, shared_ptr<Unit>>::iterator Map::unitsEnd()
	{
		return units_.end();
	}

	/**
	 * @fn
	 * ユニットのマス移動（移動確定時）
	 * @param (unit) 対象ユニット
	*/
	void Map::confirmMove(shared_ptr<Unit> unit)
	{
		int baseX = unit->getBaseX();
		int baseY = unit->getBaseY();
		int massX = unit->getMassX();
		int massY = unit->getMassY();

		if (baseX != massX || baseY != massY) // 移動しているときのみ
		{
			unit->setPos(massX, massY);
			units_.emplace(make_pair(massX, massY), unit);
			units_.erase(make_pair(baseX, baseY));
		}
	}

	/**
	 * @fn
	 * 移動可能範囲表示
	 * @param (unit) 対象ユニット
	*/
	void Map::displayMovableRange(shared_ptr<Unit> unit)
	{
		if (unit)
		{
			bool isOwnUnit = !unit->isEnemy(); // 自軍ユニットであるか

			int move = unit->getInfo().mov;
			int x = unit->getMassX();
			int y = unit->getMassY();

			if (isOwnUnit)
			{
				// 初期位置からの攻撃範囲表示
				displayAtackRange(unit, true);
			}

			searchMovableMass(unit, x, y, move, true, !isOwnUnit); // 敵ユニットの場合は攻撃範囲表示
		}
	}

	/**
	 * @fn
	 * 移動可能範囲の探索
	 * @param (unit) 対象ユニット
	 * @param (x) マス座標X
	 * @param (y) マス座標Y
	 * @param (move) 残移動コスト
	 * @param (isInit) 最初の探索であるか
	 * @param (isAtackAbleArea) 攻撃可能範囲の探索であるか
	*/
	void Map::searchMovableMass(shared_ptr<Unit> unit, int x, int y, int move, bool isInit, bool isAtackAbleArea)
	{
		shared_ptr<Mass> nowMass = getMass(x, y);

		// マップ外
		if (nowMass->getKind() == Mass::Kind::OUT_OF_MAP)
		{
			return;
		}

		shared_ptr<Unit> massUnit = getUnit(x, y);
		bool isOwnUnitOnMass = false; // 味方ユニットがマス上に存在するか

		
		if (!isInit) // 初回以外の処理
		{
			// マス上にユニットがいる場合(自身は無視)
			if (massUnit)
			{
				if (massUnit->isEnemy() != unit->isEnemy()) // 敵軍ユニットがいる場合は無視
				{
					return;
				}
				isOwnUnitOnMass = true;  // 味方ユニットがいる
			}

			// movコスト消費(初回はコスト消費しない)
			move = move - nowMass->getCost();
		}

		if (move > nowMass->passingMov)
		{
			if (!isOwnUnitOnMass)
			{
				if (isAtackAbleArea) 
				{
					displayAtackRange(unit, x, y); // 攻撃可能エリア表示
				}
				else
				{
					nowMass->state = Mass::State::MOVABLE; // 移動可能エリア表示
				}
			}

			// マス通過時のmovコストを保持
			nowMass->passingMov = move;

			searchMovableMass(unit, x - 1, y, move, false, isAtackAbleArea);
			searchMovableMass(unit, x + 1, y, move, false, isAtackAbleArea);
			searchMovableMass(unit, x, y - 1, move, false, isAtackAbleArea);
			searchMovableMass(unit, x, y + 1, move, false, isAtackAbleArea);
		}
	}

	/**
	 * @fn
	 * 現在地の攻撃可能範囲表示
	 * @param (unit) 対象ユニット
	*/
	void Map::displayAtackRange(shared_ptr<Unit> unit, bool isExistEnemyOnly)
	{
		if (unit)
		{
			displayAtackRange(unit, unit->getMassX(), unit->getMassY(), isExistEnemyOnly);
		}
	}

	/**
	 * @fn
	 * 対象マス座標からの攻撃可能範囲表示
	 * @param (unit) 対象ユニット
	 * @param (x) マス座標X
	 * @param (y) マス座標Y
	*/
	void Map::displayAtackRange(shared_ptr<Unit> unit, int x, int y, bool isExistEnemyOnly)
	{
		if (unit)
		{
			int range = unit->getInfo().range;

			for (int i = 1; i <= range; i++)
			{
				setAtackMass(x - i, y, isExistEnemyOnly);
				setAtackMass(x + i, y, isExistEnemyOnly);
				setAtackMass(x, y - i, isExistEnemyOnly);
				setAtackMass(x, y + i, isExistEnemyOnly);
			}
		}
	}

	/**
	 * @fn
	 * 対象マスを攻撃可能マスにセット
	 * @param (x) マス座標X
	 * @param (y) マス座標Y
	 * @param (isExistEnemyOnly) trueの場合、敵ユニットが存在する時のみ攻撃可能にする
	*/
	void Map::setAtackMass(int x, int y, bool isExistEnemyOnly)
	{
		shared_ptr<Mass> nowMass = getMass(x, y);

		// マップ外
		if (nowMass->getKind() == Mass::Kind::OUT_OF_MAP)
		{
			return;
		}

		if (!isExistEnemyOnly)
		{
			nowMass->state = Mass::ATK_ABLE;
		}
		else
		{
			// 敵ユニットが存在する場合のみ攻撃可能にする
			shared_ptr<Unit> unit = getUnit(x, y);
			if (unit && unit->isEnemy())
			{
				nowMass->state = Mass::ATK_ABLE;
			}
		}
	}

	/**
	 * @fn
	 * マスのポインタを返す
	 * @param (x) マスのx座標
	 * @param (y) マスのy座標
	 * @return マス
	 */
	shared_ptr<Mass> Map::getMass(int massX, int massY)
	{
		if (isRange(massX, massY))
		{
			try
			{
				return mass_.at(massY).at(massX);
			}
			catch (out_of_range&) {}
		}

		shared_ptr<Mass> mass = make_shared<Mass>();
		return mass;
	}

	/**
	 * @fn
	 * マスの状態を初期化する
	 */
	void Map::clearMassState()
	{
		for (auto line = mass_.begin(); line != mass_.end(); ++line) {
			for (auto cell = (*line).begin(); cell != (*line).end(); ++cell) {
				(*cell)->state = Mass::State::NORMAL;
				(*cell)->passingMov = -1;
			}
		}
	}

	/**
	 * @fn
	 * マップ範囲内であるか判定
	 * @param (x) マスのx座標
	 * @param (y) マスのy座標
	 * @return 範囲内である場合はtrueを返す
	 */
	bool Map::isRange(int x, int y) const
	{
		return 0 <= x && x < MAP_MASS_W && 0 <= y && y < MAP_MASS_H;
	}


	/**
	 * @fn
	 * 移動可能範囲のマスを描画
	 * @param (realX) x座標
	 * @param (realY) y座標
	 */
	void Map::drawMoveableMass(int realX, int realY)
	{
		DxLib::DrawGraph(realX, realY, Utility::ResourceManager::getInstance().getImage(ImageType::IMAGE, ImageId::MASS_MOVE), TRUE);
	}

	/**
	 * @fn
	 * 攻撃可能範囲のマスを描画
	 * @param (realX) x座標
	 * @param (realY) y座標
	 */
	void Map::drawAtackMass(int realX, int realY)
	{
		DxLib::DrawGraph(realX, realY, Utility::ResourceManager::getInstance().getImage(ImageType::IMAGE, ImageId::MASS_ATACK), TRUE);
	}

	/**
	 * @fn
	 * ホバーマスを描画
	 * @param (realX) x座標
	 * @param (realY) y座標
	 */
	void Map::drawHoverMass(int realX, int realY)
	{
		DxLib::SetDrawBlendMode(DX_BLENDMODE_ALPHA, MASS_EFFECT_ALPHA);
		DxLib::DrawBox(realX, realY, realX + CHIP_SIZE, realY + CHIP_SIZE, Utility::ResourceManager::getInstance().getColor(ColorType::MAIN_COLOR), TRUE);
		DxLib::SetDrawBlendMode(DX_BLENDMODE_NOBLEND, 0);
	}

	/**
	 * @fn
	 * 選択中のマスを描画
	 * @param (realX) x座標
	 * @param (realY) y座標
	 */
	void Map::drawSelectedMass(int realX, int realY)
	{
		DxLib::SetDrawBlendMode(DX_BLENDMODE_ALPHA, MASS_EFFECT_ALPHA);
		DxLib::DrawBox(realX, realY, realX + CHIP_SIZE, realY + CHIP_SIZE, Utility::ResourceManager::getInstance().getColor(ColorType::MAIN_COLOR_ON), TRUE);
		DxLib::SetDrawBlendMode(DX_BLENDMODE_NOBLEND, 0);
	}

	/**
	 * @fn
	 * マスの座標から正味の座標を取得(x座標)
	 * @param (massX) マス座標X
	 */
	int Map::getRealX(int massX)
	{
		return massX * CHIP_SIZE;
	}

	/**
	 * @fn
	 * マスの座標から正味の座標を取得(y座標)
	 * @param (massY) マス座標Y
	 */
	int Map::getRealY(int massY)
	{
		return massY * CHIP_SIZE + MAP_Y;
	}

	/**
	 * @fn
	 * 正味の座標からマスの座標を取得(x座標)
	 * @param (realX) 正味のX座標
	 */
	int Map::getMassX(int realX)
	{
		return realX / CHIP_SIZE;
	}

	/**
	 * @fn
	 * 正味の座標からマスの座標を取得(y座標)
	 * @param (realY) 正味のY座標
	 */
	int Map::getMassY(int realY)
	{
		return (realY - MAP_Y) / CHIP_SIZE;
	}

	/**
	 * @fn
	 * マス座標を基準にマス間の距離を取得
	 * @param x0 基準地点のX座標
	 * @param y0 基準地点のY座標
	 * @param x1 対象地点のX座標
	 * @param y1 対象地点のY座標
	 * @return マス座標基準の距離
	 */
	int Map::getMassDistance(int x0, int y0, int x1, int y1)
	{
		return abs(x0 - x1) + abs(y0 - y1);
	}

}